"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const info_1 = require("../session/events/info");
const file_request_1 = __importDefault(require("./file-request"));
const destination_request_1 = __importDefault(require("./destination-request"));
const promisify_stream_1 = __importDefault(require("../utils/promisify-stream"));
const configure_response_event_1 = __importDefault(require("../session/events/configure-response-event"));
const request_event_1 = __importDefault(require("../session/events/request-event"));
const response_event_1 = __importDefault(require("../session/events/response-event"));
const names_1 = __importDefault(require("../session/events/names"));
const configure_response_event_options_1 = __importDefault(require("../session/events/configure-response-event-options"));
const buffer_1 = require("../utils/buffer");
const stream_1 = require("stream");
const messages_1 = require("../messages");
const logger_1 = __importDefault(require("../utils/logger"));
const http_header_parser_1 = require("./http-header-parser");
// An empty line that indicates the end of the header section
// https://tools.ietf.org/html/rfc7230#section-3
const HTTP_BODY_SEPARATOR = '\r\n\r\n';
// Used to calculate the recommended maximum header size
// See getRecommendedMaxHeaderSize() below
const HEADER_SIZE_MULTIPLIER = 2;
const HEADER_SIZE_CALCULATION_PRECISION = 2;
// Calculates the HTTP header size in bytes that a customer should specify via the
// --max-http-header-size Node option so that the proxy can process the site
// https://nodejs.org/api/cli.html#cli_max_http_header_size_size
// Example:
// (8211 * 2).toPrecision(2) -> 16 * 10^3 -> 16000
function getRecommendedMaxHeaderSize(currentHeaderSize) {
    return Number((currentHeaderSize * HEADER_SIZE_MULTIPLIER).toPrecision(HEADER_SIZE_CALCULATION_PRECISION));
}
function sendRequest(ctx) {
    return new Promise(resolve => {
        const req = ctx.isFileProtocol ? new file_request_1.default(ctx.reqOpts.url) : new destination_request_1.default(ctx.reqOpts, ctx.serverInfo.cacheRequests);
        ctx.goToNextStage = false;
        req.on('response', (res) => {
            if (ctx.isWebSocketConnectionReset) {
                res.destroy();
                resolve();
                return;
            }
            ctx.destRes = res;
            ctx.goToNextStage = true;
            ctx.buildContentInfo();
            ctx.calculateIsDestResReadableEnded();
            ctx.createCacheEntry(res);
            resolve();
        });
        req.on('error', err => {
            // NOTE: Sometimes the underlying socket emits an error event. But if we have a response body,
            // we can still process such requests. (B234324)
            if (!ctx.isDestResReadableEnded) {
                const rawHeadersStr = err.rawPacket ? err.rawPacket.asciiSlice().split(HTTP_BODY_SEPARATOR)[0].split('\n').splice(1).join('\n') : '';
                const headerSize = rawHeadersStr.length;
                error(ctx, messages_1.getText(messages_1.MESSAGE.destConnectionTerminated, {
                    url: ctx.dest.url,
                    message: messages_1.MESSAGE.nodeError[err.code] || err.toString(),
                    headerSize: headerSize,
                    recommendedMaxHeaderSize: getRecommendedMaxHeaderSize(headerSize).toString(),
                    invalidChars: http_header_parser_1.getFormattedInvalidCharacters(rawHeadersStr)
                }));
            }
            resolve();
        });
        req.on('fatalError', err => {
            if (ctx.isFileProtocol)
                logger_1.default.destination.onFileReadError(ctx, err);
            error(ctx, err);
            resolve();
        });
        req.on('socketHangUp', () => {
            ctx.req.socket.end();
            resolve();
        });
        if (req instanceof file_request_1.default) {
            logger_1.default.destination.onFileRead(ctx);
            req.init();
        }
    });
}
exports.sendRequest = sendRequest;
function error(ctx, err) {
    if (ctx.isPage && !ctx.isIframe)
        ctx.session.handlePageError(ctx, err);
    else if (ctx.isAjax)
        ctx.req.destroy();
    else
        ctx.closeWithError(500, err.toString());
}
exports.error = error;
async function callResponseEventCallbackForProcessedRequest(ctx, configureResponseEvent) {
    const responseInfo = new info_1.ResponseInfo(ctx);
    const preparedResponseInfo = new info_1.PreparedResponseInfo(responseInfo, configureResponseEvent.opts);
    const responseEvent = new response_event_1.default(configureResponseEvent.requestFilterRule, preparedResponseInfo);
    await ctx.session.callRequestEventCallback(names_1.default.onResponse, configureResponseEvent.requestFilterRule, responseEvent);
    return responseEvent;
}
exports.callResponseEventCallbackForProcessedRequest = callResponseEventCallbackForProcessedRequest;
async function callOnRequestEventCallback(ctx, rule, reqInfo) {
    const requestEvent = new request_event_1.default(rule, ctx, reqInfo);
    await ctx.session.callRequestEventCallback(names_1.default.onRequest, rule, requestEvent);
    return requestEvent;
}
exports.callOnRequestEventCallback = callOnRequestEventCallback;
async function callOnResponseEventCallbackForFailedSameOriginCheck(ctx, rule, configureOpts) {
    const responseInfo = new info_1.ResponseInfo(ctx);
    const preparedResponseInfo = new info_1.PreparedResponseInfo(responseInfo, configureOpts);
    const responseEvent = new response_event_1.default(rule, preparedResponseInfo);
    await ctx.session.callRequestEventCallback(names_1.default.onResponse, rule, responseEvent);
    return responseEvent;
}
exports.callOnResponseEventCallbackForFailedSameOriginCheck = callOnResponseEventCallbackForFailedSameOriginCheck;
async function callOnConfigureResponseEventForNonProcessedRequest(ctx) {
    await ctx.forEachRequestFilterRule(async (rule) => {
        const configureResponseEvent = new configure_response_event_1.default(rule, ctx, configure_response_event_options_1.default.DEFAULT);
        await ctx.session.callRequestEventCallback(names_1.default.onConfigureResponse, rule, configureResponseEvent);
        ctx.onResponseEventData.push({ rule, opts: configureResponseEvent.opts });
    });
}
exports.callOnConfigureResponseEventForNonProcessedRequest = callOnConfigureResponseEventForNonProcessedRequest;
async function callOnResponseEventCallbackWithBodyForNonProcessedRequest(ctx, onResponseEventDataWithBody) {
    const destResBodyCollectorStream = new stream_1.PassThrough();
    ctx.destRes.pipe(destResBodyCollectorStream);
    promisify_stream_1.default(destResBodyCollectorStream).then(async (data) => {
        ctx.saveNonProcessedDestResBody(data);
        const responseInfo = new info_1.ResponseInfo(ctx);
        await Promise.all(onResponseEventDataWithBody.map(async ({ rule, opts }) => {
            const preparedResponseInfo = new info_1.PreparedResponseInfo(responseInfo, opts);
            const responseEvent = new response_event_1.default(rule, preparedResponseInfo);
            await ctx.session.callRequestEventCallback(names_1.default.onResponse, rule, responseEvent);
        }));
        buffer_1.toReadableStream(data).pipe(ctx.res);
    });
}
exports.callOnResponseEventCallbackWithBodyForNonProcessedRequest = callOnResponseEventCallbackWithBodyForNonProcessedRequest;
async function callOnResponseEventCallbackWithoutBodyForNonProcessedResource(ctx, onResponseEventDataWithoutBody) {
    const responseInfo = new info_1.ResponseInfo(ctx);
    await Promise.all(onResponseEventDataWithoutBody.map(async (item) => {
        const preparedResponseInfo = new info_1.PreparedResponseInfo(responseInfo, item.opts);
        const responseEvent = new response_event_1.default(item.rule, preparedResponseInfo);
        await ctx.session.callRequestEventCallback(names_1.default.onResponse, item.rule, responseEvent);
    }));
    ctx.destRes.pipe(ctx.res);
}
exports.callOnResponseEventCallbackWithoutBodyForNonProcessedResource = callOnResponseEventCallbackWithoutBodyForNonProcessedResource;
async function callOnResponseEventCallbackForMotModifiedResource(ctx) {
    const responseInfo = new info_1.ResponseInfo(ctx);
    await Promise.all(ctx.onResponseEventData.map(async (item) => {
        const preparedResponseInfo = new info_1.PreparedResponseInfo(responseInfo, item.opts);
        const responseEvent = new response_event_1.default(item.rule, preparedResponseInfo);
        await ctx.session.callRequestEventCallback(names_1.default.onResponse, item.rule, responseEvent);
    }));
    ctx.res.end();
}
exports.callOnResponseEventCallbackForMotModifiedResource = callOnResponseEventCallbackForMotModifiedResource;
